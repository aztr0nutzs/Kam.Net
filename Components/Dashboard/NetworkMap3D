import React, { useEffect, useRef, useState } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { CSS2DRenderer, CSS2DObject } from "three/examples/jsm/renderers/CSS2DRenderer";
import { Maximize2, Minimize2, RotateCcw } from "lucide-react";

export default function NetworkMap3D({ devices, onDeviceClick }) {
  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const labelRendererRef = useRef(null);
  const controlsRef = useRef(null);
  const nodesRef = useRef(new Map());
  const instancedMeshRef = useRef(null);
  const frameIdRef = useRef(null);
  const physicsRef = useRef({ velocities: new Map(), forces: new Map() });
  const statsRef = useRef({ fps: 0, nodeCount: 0, lastUpdate: Date.now() });
  const [isFullscreen, setIsFullscreen] = useState(false);

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 50, 200);
    sceneRef.current = scene;

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 50, 100);
    cameraRef.current = camera;

    // WebGL Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // CSS2D Renderer for labels
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    containerRef.current.appendChild(labelRenderer.domElement);
    labelRendererRef.current = labelRenderer;

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 20;
    controls.maxDistance = 300;
    controlsRef.current = controls;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.left = -100;
    directionalLight.shadow.camera.right = 100;
    directionalLight.shadow.camera.top = 100;
    directionalLight.shadow.camera.bottom = -100;
    scene.add(directionalLight);

    // Point lights for cyberpunk effect
    const pointLight1 = new THREE.PointLight(0x00E8F2, 1, 100);
    pointLight1.position.set(30, 30, 30);
    scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0xB700FF, 1, 100);
    pointLight2.position.set(-30, 30, -30);
    scene.add(pointLight2);

    // Grid helper
    const gridHelper = new THREE.GridHelper(200, 50, 0x00E8F2, 0x444444);
    gridHelper.material.opacity = 0.2;
    gridHelper.material.transparent = true;
    scene.add(gridHelper);

    // Handle window resize
    const handleResize = () => {
      if (!containerRef.current) return;
      const width = containerRef.current.clientWidth;
      const height = containerRef.current.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      labelRenderer.setSize(width, height);
    };
    window.addEventListener('resize', handleResize);

    // Expose debug info
    window.__mapDebug = () => ({
      nodeCount: statsRef.current.nodeCount,
      fps: statsRef.current.fps,
      lastUpdate: new Date(statsRef.current.lastUpdate).toISOString(),
      cameraPosition: camera.position,
      deviceCount: devices.length,
      instancedMeshCount: instancedMeshRef.current?.count || 0,
    });

    // Animation loop
    let lastTime = performance.now();
    let frames = 0;
    let fpsTime = 0;

    const animate = () => {
      frameIdRef.current = requestAnimationFrame(animate);

      const currentTime = performance.now();
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // FPS calculation
      frames++;
      fpsTime += deltaTime;
      if (fpsTime >= 1) {
        statsRef.current.fps = Math.round(frames / fpsTime);
        frames = 0;
        fpsTime = 0;
      }

      // Update physics
      updatePhysics(deltaTime);

      // Update controls
      controls.update();

      // Billboarding - make labels face camera
      nodesRef.current.forEach((nodeData) => {
        if (nodeData.label) {
          nodeData.label.lookAt(camera.position);
        }
      });

      // Render
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    };
    animate();

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      if (frameIdRef.current) {
        cancelAnimationFrame(frameIdRef.current);
      }
      renderer.dispose();
      controls.dispose();
      delete window.__mapDebug;
    };
  }, []);

  // Update nodes when devices change
  useEffect(() => {
    if (!sceneRef.current) return;
    updateNodes(devices);
    statsRef.current.lastUpdate = Date.now();
    statsRef.current.nodeCount = devices.length;
  }, [devices]);

  // Physics simulation with force-repulsion
  const updatePhysics = (deltaTime) => {
    const scene = sceneRef.current;
    if (!scene) return;

    const nodes = Array.from(nodesRef.current.values());
    const repulsionStrength = 30;
    const dampingFactor = 0.9;
    const centerAttraction = 0.01;

    // Reset forces
    nodes.forEach(node => {
      if (!physicsRef.current.forces.has(node.id)) {
        physicsRef.current.forces.set(node.id, new THREE.Vector3());
      }
      physicsRef.current.forces.get(node.id).set(0, 0, 0);
    });

    // Calculate repulsion forces between nodes
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const nodeA = nodes[i];
        const nodeB = nodes[j];

        const distance = nodeA.mesh.position.distanceTo(nodeB.mesh.position);
        if (distance < 0.1) continue;

        const direction = new THREE.Vector3()
          .subVectors(nodeA.mesh.position, nodeB.mesh.position)
          .normalize();

        const force = repulsionStrength / (distance * distance);

        const forceA = physicsRef.current.forces.get(nodeA.id);
        const forceB = physicsRef.current.forces.get(nodeB.id);

        forceA.add(direction.clone().multiplyScalar(force));
        forceB.sub(direction.clone().multiplyScalar(force));
      }
    }

    // Apply forces and update positions
    nodes.forEach(node => {
      if (!physicsRef.current.velocities.has(node.id)) {
        physicsRef.current.velocities.set(node.id, new THREE.Vector3());
      }

      const velocity = physicsRef.current.velocities.get(node.id);
      const force = physicsRef.current.forces.get(node.id);

      // Center attraction
      const toCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), node.mesh.position);
      force.add(toCenter.multiplyScalar(centerAttraction));

      // Update velocity
      velocity.add(force.multiplyScalar(deltaTime));
      velocity.multiplyScalar(dampingFactor);

      // Update position with smooth interpolation
      const targetPosition = node.mesh.position.clone().add(velocity);
      node.mesh.position.lerp(targetPosition, 0.1);

      // Update label position
      if (node.label) {
        node.label.position.copy(node.mesh.position);
      }
    });
  };

  // Update or create nodes
  const updateNodes = (devices) => {
    const scene = sceneRef.current;
    if (!scene) return;

    const existingIds = new Set(nodesRef.current.keys());
    const newIds = new Set(devices.map(d => d.id));

    // Remove nodes that no longer exist
    existingIds.forEach(id => {
      if (!newIds.has(id)) {
        const nodeData = nodesRef.current.get(id);
        scene.remove(nodeData.mesh);
        if (nodeData.label) {
          scene.remove(nodeData.label);
        }
        nodesRef.current.delete(id);
      }
    });

    // Add or update nodes
    devices.forEach((device, index) => {
      if (nodesRef.current.has(device.id)) {
        // Update existing node
        updateNode(device);
      } else {
        // Create new node
        createNode(device, index);
      }
    });
  };

  // Create a new node
  const createNode = (device, index) => {
    const scene = sceneRef.current;
    if (!scene) return;

    // Determine size by signal strength or response time
    const size = device.response_time
      ? Math.max(0.5, 3 - (device.response_time / 100))
      : 2;

    // Determine color by status
    const color = getStatusColor(device.status, device.threat_level);

    // Create geometry - use instancing for performance
    const geometry = new THREE.SphereGeometry(size, 32, 32);
    const material = new THREE.MeshPhongMaterial({
      color: color,
      emissive: color,
      emissiveIntensity: 0.5,
      transparent: true,
      opacity: 0.9,
    });

    const mesh = new THREE.Mesh(geometry, material);

    // Initial position in a spiral pattern
    const angle = (index / devices.length) * Math.PI * 2;
    const radius = 20 + (index % 5) * 10;
    mesh.position.set(
      Math.cos(angle) * radius,
      (Math.random() - 0.5) * 20,
      Math.sin(angle) * radius
    );

    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.userData = { deviceId: device.id };

    // Add glow effect
    const glowGeometry = new THREE.SphereGeometry(size * 1.2, 16, 16);
    const glowMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.3,
      side: THREE.BackSide,
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    mesh.add(glow);

    scene.add(mesh);

    // Create label with CSS2D
    const labelDiv = document.createElement('div');
    labelDiv.className = 'node-label';
    labelDiv.style.cssText = `
      color: ${getColorHex(color)};
      font-family: monospace;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.8);
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid ${getColorHex(color)};
      pointer-events: auto;
      cursor: pointer;
      white-space: nowrap;
      backdrop-filter: blur(4px);
    `;
    labelDiv.textContent = device.hostname || device.ip_address;
    labelDiv.addEventListener('click', () => onDeviceClick && onDeviceClick(device));

    const label = new CSS2DObject(labelDiv);
    label.position.copy(mesh.position);
    scene.add(label);

    // Animate entrance
    mesh.scale.set(0, 0, 0);
    animateScale(mesh, { x: 1, y: 1, z: 1 }, 500);

    nodesRef.current.set(device.id, {
      id: device.id,
      mesh,
      label,
      device,
    });
  };

  // Update existing node
  const updateNode = (device) => {
    const nodeData = nodesRef.current.get(device.id);
    if (!nodeData) return;

    const newColor = getStatusColor(device.status, device.threat_level);

    // Animate color change
    animateColor(nodeData.mesh.material, newColor, 500);

    // Update label
    if (nodeData.label) {
      const labelDiv = nodeData.label.element;
      labelDiv.textContent = device.hostname || device.ip_address;
      labelDiv.style.color = getColorHex(newColor);
      labelDiv.style.borderColor = getColorHex(newColor);
    }

    nodeData.device = device;
  };

  // Animate scale
  const animateScale = (object, target, duration) => {
    const start = { ...object.scale };
    const startTime = Date.now();

    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const eased = easeOutElastic(progress);

      object.scale.set(
        start.x + (target.x - start.x) * eased,
        start.y + (target.y - start.y) * eased,
        start.z + (target.z - start.z) * eased
      );

      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };
    animate();
  };

  // Animate color
  const animateColor = (material, targetColor, duration) => {
    const start = material.color.clone();
    const target = new THREE.Color(targetColor);
    const startTime = Date.now();

    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);

      material.color.lerpColors(start, target, progress);
      material.emissive.copy(material.color);

      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };
    animate();
  };

  // Get status color
  const getStatusColor = (status, threatLevel) => {
    if (threatLevel === 'critical') return 0xFF0000;
    if (threatLevel === 'high') return 0xFF4500;
    if (threatLevel === 'medium') return 0xFFFF00;

    switch (status) {
      case 'online': return 0x00FF41;
      case 'warning': return 0xFFFF00;
      case 'critical': return 0xFF0000;
      case 'offline': return 0x888888;
      default: return 0x00E8F2;
    }
  };

  // Convert color to hex string
  const getColorHex = (color) => {
    return '#' + new THREE.Color(color).getHexString();
  };

  // Easing function
  const easeOutElastic = (x) => {
    const c4 = (2 * Math.PI) / 3;
    return x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;
  };

  // Reset camera
  const handleReset = () => {
    if (cameraRef.current && controlsRef.current) {
      cameraRef.current.position.set(0, 50, 100);
      controlsRef.current.target.set(0, 0, 0);
      controlsRef.current.update();
    }
  };

  // Toggle fullscreen
  const handleFullscreen = () => {
    if (!document.fullscreenElement) {
      containerRef.current?.requestFullscreen();
      setIsFullscreen(true);
    } else {
      document.exitFullscreen();
      setIsFullscreen(false);
    }
  };

  return (
    <div className="relative bg-black/60 backdrop-blur-lg border-2 border-cyan-400/30 rounded-xl overflow-hidden shadow-2xl">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-cyan-400/20">
        <div className="flex items-center gap-3">
          <div className="w-3 h-3 bg-cyan-400 rounded-full animate-pulse" />
          <h3 className="text-xl font-bold text-cyan-400 font-mono">3D NETWORK MAP</h3>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={handleReset}
            className="p-2 rounded-lg bg-purple-500/20 hover:bg-purple-500/30 text-purple-400 border border-purple-400/50 transition-all"
            title="Reset View"
          >
            <RotateCcw className="w-4 h-4" />
          </button>
          <button
            onClick={handleFullscreen}
            className="p-2 rounded-lg bg-cyan-500/20 hover:bg-cyan-500/30 text-cyan-400 border border-cyan-400/50 transition-all"
            title="Toggle Fullscreen"
          >
            {isFullscreen ? <Minimize2 className="w-4 h-4" /> : <Maximize2 className="w-4 h-4" />}
          </button>
        </div>
      </div>

      {/* 3D Canvas Container */}
      <div ref={containerRef} className="w-full h-[600px] relative" />

      {/* Legend */}
      <div className="absolute bottom-4 left-4 bg-black/80 backdrop-blur-sm border border-cyan-400/30 rounded-lg p-3 font-mono text-xs">
        <div className="space-y-2">
          <div className="flex items-center gap-2">
            <div className="w-3 h-3 rounded-full bg-green-400" />
            <span className="text-green-400">Online</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-3 h-3 rounded-full bg-yellow-400" />
            <span className="text-yellow-400">Warning</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-3 h-3 rounded-full bg-red-400" />
            <span className="text-red-400">Critical</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-3 h-3 rounded-full bg-gray-400" />
            <span className="text-gray-400">Offline</span>
          </div>
        </div>
      </div>

      {/* Stats */}
      <div className="absolute bottom-4 right-4 bg-black/80 backdrop-blur-sm border border-cyan-400/30 rounded-lg p-3 font-mono text-xs">
        <div className="space-y-1 text-cyan-400">
          <div>Nodes: {statsRef.current.nodeCount}</div>
          <div>FPS: {statsRef.current.fps}</div>
        </div>
      </div>

      {/* Corner brackets */}
      <div className="absolute top-2 left-2 w-6 h-6 border-l-2 border-t-2 border-cyan-400 opacity-50 pointer-events-none" />
      <div className="absolute top-2 right-2 w-6 h-6 border-r-2 border-t-2 border-cyan-400 opacity-50 pointer-events-none" />
      <div className="absolute bottom-2 left-2 w-6 h-6 border-l-2 border-b-2 border-cyan-400 opacity-50 pointer-events-none" />
      <div className="absolute bottom-2 right-2 w-6 h-6 border-r-2 border-b-2 border-cyan-400 opacity-50 pointer-events-none" />
    </div>
  );
}
